# -*- coding: utf-8 -*-
"""lab-supervised-learning-feature-extraction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fmxrnJbD6Tv0wMlGErYavd1Wio9w-p-g

# Before your start:
- Read the README.md file
- Comment as much as you can and use the resources in the README.md file
- Happy learning!
"""

#Import your libraries
import numpy as np
import pandas as pd

"""# Introduction

In this lab, we will use two datasets. Both datasets contain variables that describe apps from the Google Play Store. We will use our knowledge in feature extraction to process these datasets and prepare them for the use of a ML algorithm.

# Challenge 1 - Loading and Extracting Features from the First Dataset

#### In this challenge, our goals are:

* Exploring the dataset.
* Identify the columns with missing values.
* Either replacing the missing values in each column or drop the columns.
* Conver each column to the appropriate type.

#### The first dataset contains different information describing the apps.

Load the dataset into the variable `google_play` in the cell below. The dataset is in the file `googleplaystore.csv`
"""

# Your code here:
df = pd.read_csv("/content/googleplaystore.csv")
df.head()

print("Dataset Information:")
print(df.info())

missing_values = df.isnull().sum()

# Display columns with missing values
print("Columns with Missing Values:")
print(missing_values[missing_values > 0])

df.dtypes

#df.fillna(df.mean(), inplace=True)

"""#### Examine all variables and their types in the following cell"""

# Your code here:
df.dtypes

"""#### Since this dataset only contains one numeric column, let's skip the `describe()` function and look at the first 5 rows using the `head()` function"""

# Your code here:
df.head(5)

print("First 5 Rows of the Dataset:")
print(df.head())

"""#### We can see that there are a few columns that could be coerced to numeric.

Start with the reviews column. We can evaluate what value is causing this column to be of object type finding the non-numeric values in this column. To do this, we recall the `to_numeric()` function. With this function, we are able to coerce all non-numeric data to null. We can then use the `isnull()` function to subset our dataframe using the True/False column that this function generates.

In the cell below, transform the Reviews column to numeric and assign this new column to the variable `Reviews_numeric`. Make sure to coerce the errors.
"""

# Transform 'Reviews' column to numeric, coercing errors
df['Reviews_numeric'] = pd.to_numeric(df['Reviews'], errors='coerce')

# Display the first 5 rows of the updated dataset
print("Updated Dataset with Reviews_numeric column:")
print(df.head())

# Your code here:
df['Reviews_numeric'] = pd.to_numeric(df['Reviews'], errors='coerce')
df['Reviews_numeric'] =df['Reviews_numeric'].astype(float)
df.head()

df.dtypes

"""Next, create a column containing True/False values using the `isnull()` function. Assign this column to the `Reviews_isnull` variable."""

# Your code here:
# Create a new column 'Reviews_isnull' with True/False values
df['Reviews_isnull'] = df['Reviews_numeric'].isnull()

# Display the first 5 rows of the updated dataset

print("Updated Dataset with Reviews_isnull column:")
display(df.head())

"""Finally, subset the `google_play` with `Reviews_isnull`. This should give you all the rows that contain non-numeric characters.

Your output should look like:

![Reviews_bool.png](../images/reviews-bool.png)
"""

# Your code here:
# Subset the dataframe based on Reviews_isnull
non_numeric_reviews = df[df['Reviews_isnull']]

# Display the subset of the dataframe
print("Rows with Non-Numeric Reviews:")
print(non_numeric_reviews)

non_numeric_reviews.head()

"""#### We see that Google Play is using a shorthand for millions.

Let's write a function to transform this data.

Steps:

1. Create a function that returns the correct numeric values of *Reviews*.
1. Define a test string with `M` in the last character.
1. Test your function with the test string. Make sure your function works correctly. If not, modify your functions and test again.
"""

def transform_reviews(reviews):
    if 'M' in reviews:
        # Convert to numeric after removing 'M' and multiply by 1,000,000
        return float(reviews.replace('M', '')) * 1e6
    else:
        # Convert to numeric for other cases
        return pd.to_numeric(reviews, errors='coerce')

reviews_value = '3.0M'
transformed_value = transform_reviews(reviews_value)

print(f"Original Value: {reviews_value}")
print(f"Transformed Value: {transformed_value}")

test_reviews_value = '4'

# Test the transform_reviews function on the test string
transformed_value = transform_reviews(test_reviews_value)

# Display the original and transformed values
print(f"Original Value: {test_reviews_value}")
print(f"Transformed Value: {transformed_value}")

"""The last step is to apply the function to the `Reviews` column in the following cell:"""

# Your code here:
df['Reviews_transformed'] = df['Reviews'].apply(transform_reviews)

# Display the first 5 rows of the updated dataset
print("Updated Dataset with Reviews_transformed column:")
print(df.head())

"""Check the non-numeric `Reviews` row again. It should have been fixed now and you should see:

![Reviews_bool_fixed.png](../images/reviews-bool-fixed.png)
"""

# Your code here

"""Also check the variable types of `google_play`. The `Reviews` column should be a `float64` type now."""

# Your code here:
print("Variable Types of google_play:")
print(df.dtypes)

"""#### The next column we will look at is `Size`. We start by looking at all unique values in `Size`:

*Hint: use `unique()` ([documentation](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.unique.html))*.
"""

# Your code here:
unique_sizes = df['Size'].unique()

# Display the unique values
print("Unique Values in the 'Size' Column:")
print(unique_sizes)

"""You should have seen lots of unique values of the app sizes.

#### While we can convert most of the `Size` values to numeric in the same way we converted the `Reviews` values, there is one value that is impossible to convert.

What is that badass value? Enter it in the next cell and calculate the proportion of its occurence to the total number of records of `google_play`.
"""

# Your code here:
varies_with_device_proportion = (df['Size'] == 'Varies with device').sum() / len(df)

print("Proportion of 'Varies with device' in the 'Size' column:")
print(varies_with_device_proportion)

"""#### While this column may be useful for other types of analysis, we opt to drop it from our dataset.

There are two reasons. First, the majority of the data are ordinal but a sizeable proportion are missing because we cannot convert them to numerical values. Ordinal data are both numerical and categorical, and they usually can be ranked (e.g. 82k is smaller than 91M). In contrast, non-ordinal categorical data such as blood type and eye color cannot be ranked. The second reason is as a categorical column, it has too many unique values to produce meaningful insights. Therefore, in our case the simplest strategy would be to drop the column.

Drop the column in the cell below (use `inplace=True`)
"""

# Your code here:
df.drop('Size', axis=1, inplace=True)

df.head()

"""#### Now let's look at how many missing values are in each column.

This will give us an idea of whether we should come up with a missing data strategy or give up on the column all together. In the next column, find the number of missing values in each column:

*Hint: use the `isna()` and `sum()` functions.*
"""

# Your code here:
missing_values_count = df.isna().sum()

# Display the number of missing values in each column
print("Number of Missing Values in Each Column:")
missing_values_count

"""You should find the column with the most missing values is now `Rating`.

#### What is the proportion of the missing values in `Rating` to the total number of records?

Enter your answer in the cell below.
"""

# Your code here:
rating_missing_proportion = missing_values_count['Rating'] / len(df)*100

# Display the proportion of missing values in the 'Rating' column
print("Proportion of Missing Values in the 'Rating' Column:")
display(rating_missing_proportion)

"""A sizeable proportion of the `Rating` column is missing. A few other columns also contain several missing values.

#### We opt to preserve these columns and remove the rows containing missing data.

In particular, we don't want to drop the `Rating` column because:

* It is one of the most important columns in our dataset.

* Since the dataset is not a time series, the loss of these rows will not have a negative impact on our ability to analyze the data. It will, however, cause us to lose some meaningful observations. But the loss is limited compared to the gain we receive by preserving these columns.

In the cell below, remove all rows containing at least one missing value. Use the `dropna()` function ([documentation](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.dropna.html)). Assign the new dataframe to the variable `google_missing_removed`.
"""

# Your code here:
#c = df.dropna()

# Display the first 5 rows of the updated dataset
#print("Updated Dataset after Removing Rows with Missing Values:")
display(google_missing_removed.head())

"""From now on, we use the `google_missing_removed` variable instead of `google_play`.

#### Next, we look at the `Last Updated` column.

The `Last Updated` column seems to contain a date, though it is classified as an object type. Let's convert this column using the `pd.to_datetime` function ([documentation](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.to_datetime.html)).
"""

# Your code here:
google_missing_removed['Last Updated'] = pd.to_datetime(google_missing_removed['Last Updated'])

display(google_missing_removed.head())

"""#### The last column we will transform is `Price`.

We start by looking at the unique values of this column.
"""

unique_prices = google_missing_removed['Price'].unique()

display(unique_prices)

"""Since all prices are ordinal data without exceptions, we can tranform this column by removing the dollar sign and converting to numeric. We can create a new column called `Price Numerical` and drop the original column.

We will achieve our goal in three steps. Follow the instructions of each step below.

#### First we remove the dollar sign. Do this in the next cell by applying the `str.replace` function to the column to replace `$` with an empty string (`''`).
"""

# Your code here:
google_missing_removed['Price Numerical'] = google_missing_removed['Price'].str.replace('$', '')

display("Updated Dataset with 'Price Numerical' column (dollar sign removed):" , google_missing_removed.head())

"""#### Second step, coerce the `Price Numerical` column to numeric."""

# Your code here:
google_missing_removed['Price Numerical'] = pd.to_numeric(google_missing_removed['Price Numerical'], errors='coerce')

display("Updated Dataset with 'Price Numerical' column coerced to numeric:" , google_missing_removed.head())

"""**Finally, drop the original `Price` column.**"""

# Your code here:
google_missing_removed.drop('Price', axis=1, inplace=True)

display("Updated Dataset after dropping the original 'Price' column:" , google_missing_removed.head())

"""Now check the variable types of `google_missing_removed`. Make sure:

* `Size` and `Price` columns have been removed.
* `Rating`, `Reviews`, and `Price Numerical` have the type of `float64`.
* `Last Updated` has the type of `datetime64`.
"""

# Your code here:
google_missing_removed.dtypes

"""# Challenge 2 - Loading and Extracting Features from the Second Dataset

Load the second dataset to the variable `google_reviews`. The data is in the file `googleplaystore_user_reviews.csv`.
"""

# Your code here:
gv = pd.read_csv("/content/googleplaystore_user_reviews.csv")
gv

gv.head()

"""#### This dataset contains the top 100 reviews for each app.

Let's examine this dataset using the `head` function
"""

# Your code here
gv.dtypes

missing_values = gv.isnull().sum()
missing_values

print("Dataset Information:")
print(gv.info())

"""#### The main piece of information we would like to extract from this dataset is the proportion of positive reviews of each app.

Columns like `Sentiment_Polarity` and `Sentiment_Subjectivity` are not to our interests because we have no clue how to use them. We do not care about `Translated_Review` because natural language processing is too complex for us at present (in fact the `Sentiment`, `Sentiment_Polarity`, and `Sentiment_Subjectivity` columns are derived from `Translated_Review` the data scientists).

What we care about in this challenge is `Sentiment`. To be more precise, we care about **what is the proportion of *Positive* sentiment of each app**. This will require us to aggregate the `Sentiment` data by `App` in order to calculate the proportions.

Now that you are clear about what we are trying to achieve, follow the steps below that will walk you through towards our goal.
"""

gv_cleaned = gv.dropna(subset=['Sentiment'])

grouped_data = gv_cleaned.groupby('App')

positive_counts = grouped_data['Sentiment'].apply(lambda x: (x == 'Positive').sum())

total_counts = grouped_data['Sentiment'].count()
proportions = positive_counts / total_counts

result_gv = pd.DataFrame({
    'App': proportions.index,
    'Proportion_Positive': proportions.values
})

print(result_gv)

"""#### Our first step will be to remove all rows with missing sentiment.

In the next cell, drop all rows with missing data using the `dropna()` function and assign this new dataframe to `review_missing_removed`.
"""

# Assuming your DataFrame is called df
review_missing_removed = gv.dropna(subset=['Sentiment'])
gv.head()

"""#### Now, use the `value_counts()` function ([documentation](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.value_counts.html)) to get a sense on how many apps are in this dataset and their review counts."""

# Your code here:
app_review_counts = review_missing_removed['App'].value_counts()
print(app_review_counts)

"""#### Now the tough part comes. Let's plan how we will achieve our goal:

1. We will count the number of reviews that contain *Positive* in the `Sentiment` column.

1. We will create a new dataframe to contain the `App` name, the number of positive reviews, and the total number of reviews of each app.

1. We will then loop the new dataframe to calculate the postivie review portion of each app.

#### Step 1: Count the number of positive reviews.

In the following cell, write a function that takes a column and returns the number of times *Positive* appears in the column.

*Hint: One option is to use the `np.where()` function ([documentation](https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.where.html)).*
"""

# Your code below

def positive_function(x):
    """
    Count how many times the string `Positive` appears in a column (exact string match).

    Args:
        x: data column

    Returns:
        The number of occurrences of `Positive` in the column data.
    """

    return np.sum(np.where(x == 'Positive', 1, 0))

positive_count = positive_function(review_missing_removed['Sentiment'])
print("Number of Positive Reviews:", positive_count)

"""#### Step 2: Create a new dataframe to contain the `App` name, the number of positive reviews, and the total number of reviews of each app

We will group `review_missing_removed` by the `App` column, then aggregate the grouped dataframe on the number of positive reviews and the total review counts of each app. The result will be assigned to a new variable `google_agg`. Here is the ([documentation on how to achieve it](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.core.groupby.DataFrameGroupBy.agg.html)). Take a moment or two to read the documentation and google examples because it is pretty complex.

When you obtain `google_agg`, check its values to make sure it has an `App` column as its index as well as a `Positive` column and a `Total` column. Your output should look like:

![Positive Reviews Agg](../images/positive-review-agg.png)

*Hint: Use `positive_function` you created earlier as part of the param passed to the `agg()` function in order to aggregate the number of positive reviews.*

#### Bonus:

As of Pandas v0.23.4, you may opt to supply an array or an object to `agg()`. If you use the array param, you'll need to rename the columns so that their names are `Positive` and `Total`. Using the object param will allow you to create the aggregated columns with the desirable names without renaming them. However, you will probably encounter a warning indicating supplying an object to `agg()` will become outdated. It's up to you which way you will use. Try both ways out. Any way is fine as long as it works.
"""

# Your code here:

google_agg = review_missing_removed.groupby('App').agg({
    'Sentiment': [positive_function, 'count']
})
google_agg.columns = ['Positive', 'Total']

"""Print the first 5 rows of `google_agg` to check it."""

# Your code here
google_agg.head()

"""#### Add a derived column to `google_agg` that is the ratio of the `Positive` and the `Total` columns. Call this column `Positive Ratio`.

Make sure to account for the case where the denominator is zero using the `np.where()` function.
"""

# Your code here:

google_agg['Positive Ratio'] = np.where(google_agg['Total'] != 0,
                                        google_agg['Positive'] / google_agg['Total'],
                                        0)
google_agg.head()

"""#### Now drop the `Positive` and `Total` columns. Do this with `inplace=True`."""

# Your code here:
google_agg.drop(["Positive", "Positive"], axis=1, inplace=True)

"""Print the first 5 rows of `google_agg`. Your output should look like:

![Positive Reviews Agg](../images/positive-review-ratio.png)
"""

# Your code here:
google_agg.head()

"""# Challenge 3 - Join the Dataframes

In this part of the lab, we will join the two dataframes and obtain a dataframe that contains features we can use in our ML algorithm.

In the next cell, join the `google_missing_removed` dataframe with the `google_agg` dataframe on the `App` column. Assign this dataframe to the variable `google`.
"""

# Your code here:
google = pd.merge(google_missing_removed, google_agg, on='App')

google.head()

"""#### Let's look at the final result using the `head()` function. Your final product should look like:

![Final Product](../images/google-final-head.png)
"""

# Your code here: